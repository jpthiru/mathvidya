<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Take Exam - Mathvidya</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <!-- Main CSS -->
  <link rel="stylesheet" href="../css/main.css">

  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    /* ========== Exam Layout ========== */
    body {
      overflow-x: hidden;
    }

    /* Header */
    .exam-header {
      position: sticky;
      top: 0;
      background: white;
      border-bottom: 2px solid var(--color-gray-200);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: var(--z-sticky);
      box-shadow: var(--shadow-md);
    }

    .exam-logo {
      font-family: var(--font-heading);
      font-size: var(--text-2xl);
      font-weight: 700;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .exam-timer {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .timer-display {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-family: var(--font-heading);
      font-size: var(--text-xl);
      font-weight: 600;
      color: var(--color-gray-800);
      padding: 0.75rem 1.5rem;
      background: var(--color-gray-100);
      border-radius: var(--radius-lg);
    }

    .timer-display.warning {
      background: #FEF3C7;
      color: #92400E;
      animation: pulse 1s infinite;
    }

    .timer-display.critical {
      background: #FEE2E2;
      color: #991B1B;
      animation: pulse 0.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Main Container */
    .exam-container {
      display: flex;
      min-height: calc(100vh - 80px);
      gap: 2rem;
      padding: 2rem;
      max-width: 1600px;
      margin: 0 auto;
    }

    /* Left Column - Question Display */
    .question-panel {
      flex: 1;
      min-width: 0; /* Prevent flex overflow */
    }

    .progress-bar-container {
      background: var(--color-gray-100);
      border-radius: var(--radius-full);
      height: 8px;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .progress-bar-fill {
      height: 100%;
      background: var(--gradient-primary);
      transition: width var(--transition-base);
    }

    .progress-text {
      font-size: var(--text-sm);
      color: var(--color-gray-600);
      margin-bottom: 1.5rem;
      font-weight: 500;
    }

    .question-card {
      background: white;
      border-radius: var(--radius-xl);
      padding: 2rem;
      box-shadow: var(--shadow-lg);
      margin-bottom: 1.5rem;
    }

    .question-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid var(--color-gray-200);
    }

    .question-number {
      font-family: var(--font-heading);
      font-size: var(--text-xl);
      font-weight: 700;
      color: var(--color-primary);
    }

    .question-marks {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.5rem 1rem;
      background: var(--color-primary);
      color: white;
      border-radius: var(--radius-full);
      font-size: var(--text-sm);
      font-weight: 600;
    }

    .question-text {
      font-size: var(--text-lg);
      line-height: 1.8;
      color: var(--color-gray-800);
      margin-bottom: 1.5rem;
      min-height: 60px;
    }

    /* LaTeX/Math notation will be rendered here */
    .question-text .math {
      font-style: italic;
      color: var(--color-primary);
    }

    .question-image {
      max-width: 100%;
      height: auto;
      border-radius: var(--radius-lg);
      margin-bottom: 1.5rem;
      box-shadow: var(--shadow-md);
    }

    .question-image.hidden {
      display: none;
    }

    /* Answer Options */
    .answer-options {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .option-item {
      position: relative;
    }

    .option-item input[type="radio"] {
      position: absolute;
      opacity: 0;
      cursor: pointer;
    }

    .option-label {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1.25rem 1.5rem;
      background: var(--color-gray-50);
      border: 2px solid var(--color-gray-200);
      border-radius: var(--radius-lg);
      cursor: pointer;
      transition: all var(--transition-fast);
      font-size: var(--text-base);
      line-height: 1.6;
    }

    .option-item:hover .option-label {
      border-color: var(--color-primary-light);
      background: var(--color-gray-100);
    }

    .option-item input:checked + .option-label {
      border-color: var(--color-primary);
      background: rgba(99, 102, 241, 0.1);
      font-weight: 600;
    }

    .option-indicator {
      flex-shrink: 0;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid var(--color-gray-400);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: var(--color-gray-600);
      background: white;
      transition: all var(--transition-fast);
    }

    .option-item input:checked + .option-label .option-indicator {
      border-color: var(--color-primary);
      background: var(--color-primary);
      color: white;
    }

    .option-text {
      flex: 1;
    }

    /* Navigation Buttons */
    .question-navigation {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .question-navigation .btn {
      flex: 1;
      min-width: 140px;
    }

    .btn-mark-review {
      background: var(--color-warning);
      color: white;
    }

    .btn-mark-review:hover {
      background: #D97706;
    }

    /* Right Column - Question Palette */
    .palette-panel {
      width: 320px;
      flex-shrink: 0;
    }

    .palette-sticky {
      position: sticky;
      top: 100px;
    }

    .palette-card {
      background: white;
      border-radius: var(--radius-xl);
      padding: 1.5rem;
      box-shadow: var(--shadow-lg);
    }

    .palette-title {
      font-family: var(--font-heading);
      font-size: var(--text-lg);
      font-weight: 700;
      color: var(--color-gray-800);
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 2px solid var(--color-gray-200);
    }

    .palette-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .palette-question {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid var(--color-gray-300);
      background: white;
      border-radius: var(--radius-md);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-fast);
      font-size: var(--text-sm);
    }

    .palette-question:hover {
      transform: scale(1.1);
      box-shadow: var(--shadow-md);
    }

    /* Palette Question States */
    .palette-question.current {
      border-color: var(--color-primary);
      border-width: 3px;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }

    .palette-question.answered {
      background: var(--color-accent);
      color: white;
      border-color: var(--color-accent);
    }

    .palette-question.not-attempted {
      background: var(--color-gray-200);
      color: var(--color-gray-600);
      border-color: var(--color-gray-300);
    }

    .palette-question.marked {
      background: var(--color-warning);
      color: white;
      border-color: var(--color-warning);
    }

    /* Legend */
    .palette-legend {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding-top: 1rem;
      border-top: 1px solid var(--color-gray-200);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: var(--text-sm);
    }

    .legend-color {
      width: 24px;
      height: 24px;
      border-radius: var(--radius-sm);
      border: 2px solid;
      flex-shrink: 0;
    }

    .legend-color.answered {
      background: var(--color-accent);
      border-color: var(--color-accent);
    }

    .legend-color.not-attempted {
      background: var(--color-gray-200);
      border-color: var(--color-gray-300);
    }

    .legend-color.marked {
      background: var(--color-warning);
      border-color: var(--color-warning);
    }

    /* Submit Confirmation Modal */
    .exam-summary {
      line-height: 2;
    }

    .exam-summary-item {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--color-gray-200);
    }

    .exam-summary-item:last-child {
      border-bottom: none;
    }

    .summary-label {
      font-weight: 500;
      color: var(--color-gray-700);
    }

    .summary-value {
      font-weight: 700;
      font-size: var(--text-lg);
    }

    .summary-value.answered {
      color: var(--color-accent);
    }

    .summary-value.unanswered {
      color: var(--color-error);
    }

    .summary-value.marked {
      color: var(--color-warning);
    }

    /* Responsive Design */
    @media (max-width: 1024px) {
      .exam-container {
        flex-direction: column;
      }

      .palette-panel {
        width: 100%;
      }

      .palette-sticky {
        position: static;
      }

      .palette-grid {
        grid-template-columns: repeat(8, 1fr);
      }
    }

    @media (max-width: 768px) {
      .exam-header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
      }

      .exam-container {
        padding: 1rem;
      }

      .question-card {
        padding: 1.5rem;
      }

      .palette-grid {
        grid-template-columns: repeat(6, 1fr);
      }

      .question-navigation {
        flex-direction: column;
      }

      .question-navigation .btn {
        width: 100%;
      }

      .timer-display {
        font-size: var(--text-base);
        padding: 0.5rem 1rem;
      }
    }

    @media (max-width: 480px) {
      .exam-logo {
        font-size: var(--text-lg);
      }

      .palette-grid {
        grid-template-columns: repeat(5, 1fr);
      }
    }

    /* Keyboard Navigation Hint */
    .keyboard-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius-full);
      font-size: var(--text-sm);
      z-index: var(--z-tooltip);
      opacity: 0;
      transition: opacity var(--transition-base);
      pointer-events: none;
    }

    .keyboard-hint.show {
      opacity: 1;
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: var(--z-modal);
    }

    .loading-overlay.show {
      display: flex;
    }

    .loading-content {
      text-align: center;
    }

    .loading-content .spinner {
      width: 3rem;
      height: 3rem;
      margin: 0 auto 1rem;
    }
  </style>
</head>
<body>

  <!-- Header -->
  <header class="exam-header">
    <div class="exam-logo">
      <i class="fas fa-graduation-cap"></i> Mathvidya
    </div>
    <div class="exam-timer">
      <div class="timer-display" id="timerDisplay">
        <i class="fas fa-clock"></i>
        <span id="timerText">--:--</span>
      </div>
      <button class="btn btn-primary" id="submitExamBtn">
        <i class="fas fa-check-circle"></i> Submit Exam
      </button>
    </div>
  </header>

  <!-- Main Container -->
  <main class="exam-container">

    <!-- Left Column - Question Panel -->
    <section class="question-panel">

      <!-- Progress Bar -->
      <div class="progress-bar-container">
        <div class="progress-bar-fill" id="progressBar" style="width: 0%"></div>
      </div>
      <div class="progress-text" id="progressText">Question 1 of 30</div>

      <!-- Question Card -->
      <div class="question-card">

        <!-- Question Header -->
        <div class="question-header">
          <div class="question-number" id="questionNumber">Question 1</div>
          <div class="question-marks" id="questionMarks">
            <i class="fas fa-star"></i> <span>1 mark</span>
          </div>
        </div>

        <!-- Question Text -->
        <div class="question-text" id="questionText">
          Loading question...
        </div>

        <!-- Question Image (if applicable) -->
        <img src="" alt="Question diagram" class="question-image hidden" id="questionImage">

        <!-- Answer Options -->
        <div class="answer-options" id="answerOptions">
          <!-- Options will be dynamically loaded -->
        </div>

        <!-- Navigation Buttons -->
        <div class="question-navigation">
          <button class="btn btn-secondary" id="prevBtn">
            <i class="fas fa-chevron-left"></i> Previous
          </button>
          <button class="btn btn-mark-review" id="markReviewBtn">
            <i class="fas fa-bookmark"></i> Mark for Review
          </button>
          <button class="btn btn-primary" id="nextBtn">
            Next <i class="fas fa-chevron-right"></i>
          </button>
        </div>

      </div>
    </section>

    <!-- Right Column - Question Palette -->
    <aside class="palette-panel">
      <div class="palette-sticky">
        <div class="palette-card">

          <div class="palette-title">
            <i class="fas fa-th"></i> Question Palette
          </div>

          <!-- Question Grid -->
          <div class="palette-grid" id="paletteGrid">
            <!-- Palette buttons will be dynamically generated -->
          </div>

          <!-- Legend -->
          <div class="palette-legend">
            <div class="legend-item">
              <div class="legend-color answered"></div>
              <span>Answered (<span id="answeredCount">0</span>)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color not-attempted"></div>
              <span>Not Attempted (<span id="notAttemptedCount">0</span>)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color marked"></div>
              <span>Marked for Review (<span id="markedCount">0</span>)</span>
            </div>
          </div>

        </div>
      </div>
    </aside>

  </main>

  <!-- Keyboard Hint -->
  <div class="keyboard-hint" id="keyboardHint">
    Use arrow keys to navigate, A/B/C/D to select answers
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="spinner"></div>
      <p>Submitting your exam...</p>
    </div>
  </div>

  <!-- Scripts -->
  <script src="../js/api.js"></script>
  <script src="../js/main.js"></script>

  <script>
    // ==================== Exam State Management ====================

    class ExamManager {
      constructor() {
        this.examData = null;
        this.currentQuestionIndex = 0;
        this.answers = {}; // questionNumber -> selectedOption
        this.markedForReview = new Set();
        this.timeRemaining = 0; // in seconds
        this.timerInterval = null;
        this.examId = null;

        this.init();
      }

      async init() {
        // Check if exam data exists in localStorage
        const examDataStr = localStorage.getItem('current_exam');
        if (!examDataStr) {
          Toast.error('No exam data found. Redirecting to dashboard...');
          setTimeout(() => {
            window.location.href = './dashboard.html';
          }, 2000);
          return;
        }

        try {
          this.examData = JSON.parse(examDataStr);
          this.examId = this.examData.exam_id;
          this.timeRemaining = this.examData.duration_minutes * 60; // Convert to seconds

          // Load saved progress if it exists
          this.loadProgress();

          // Initialize UI
          this.renderPalette();
          this.showQuestion(0);
          this.startTimer();
          this.setupEventListeners();
          this.setupKeyboardShortcuts();

          // Show keyboard hint briefly
          this.showKeyboardHint();

        } catch (error) {
          console.error('Error initializing exam:', error);
          Toast.error('Failed to load exam data');
        }
      }

      // Load saved progress from localStorage
      loadProgress() {
        const progressKey = `exam_progress_${this.examId}`;
        const savedProgress = localStorage.getItem(progressKey);

        if (savedProgress) {
          try {
            const progress = JSON.parse(savedProgress);
            this.answers = progress.answers || {};
            this.markedForReview = new Set(progress.markedForReview || []);
            this.currentQuestionIndex = progress.currentQuestionIndex || 0;

            // Restore time if less than 5 minutes have passed
            if (progress.lastSaved && progress.timeRemaining) {
              const timePassed = Math.floor((Date.now() - progress.lastSaved) / 1000);
              if (timePassed < 300) { // 5 minutes
                this.timeRemaining = Math.max(0, progress.timeRemaining - timePassed);
              }
            }

            console.log('Progress loaded:', this.answers);
          } catch (error) {
            console.error('Error loading progress:', error);
          }
        }
      }

      // Save progress to localStorage
      saveProgress() {
        const progressKey = `exam_progress_${this.examId}`;
        const progress = {
          answers: this.answers,
          markedForReview: Array.from(this.markedForReview),
          currentQuestionIndex: this.currentQuestionIndex,
          timeRemaining: this.timeRemaining,
          lastSaved: Date.now()
        };

        localStorage.setItem(progressKey, JSON.stringify(progress));
      }

      // Setup event listeners
      setupEventListeners() {
        document.getElementById('prevBtn').addEventListener('click', () => this.previousQuestion());
        document.getElementById('nextBtn').addEventListener('click', () => this.nextQuestion());
        document.getElementById('markReviewBtn').addEventListener('click', () => this.toggleMarkReview());
        document.getElementById('submitExamBtn').addEventListener('click', () => this.confirmSubmit());
      }

      // Setup keyboard shortcuts
      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          // Don't trigger shortcuts if user is typing in an input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }

          switch (e.key) {
            case 'ArrowLeft':
              e.preventDefault();
              this.previousQuestion();
              break;
            case 'ArrowRight':
              e.preventDefault();
              this.nextQuestion();
              break;
            case 'a':
            case 'A':
              e.preventDefault();
              this.selectOption('A');
              break;
            case 'b':
            case 'B':
              e.preventDefault();
              this.selectOption('B');
              break;
            case 'c':
            case 'C':
              e.preventDefault();
              this.selectOption('C');
              break;
            case 'd':
            case 'D':
              e.preventDefault();
              this.selectOption('D');
              break;
          }
        });
      }

      // Show keyboard hint
      showKeyboardHint() {
        const hint = document.getElementById('keyboardHint');
        hint.classList.add('show');
        setTimeout(() => {
          hint.classList.remove('show');
        }, 5000);
      }

      // Render question palette
      renderPalette() {
        const paletteGrid = document.getElementById('paletteGrid');
        paletteGrid.innerHTML = '';

        this.examData.questions.forEach((question, index) => {
          const button = document.createElement('button');
          button.className = 'palette-question';
          button.textContent = index + 1;
          button.addEventListener('click', () => this.showQuestion(index));
          paletteGrid.appendChild(button);
        });

        this.updatePalette();
      }

      // Update palette button states
      updatePalette() {
        const buttons = document.querySelectorAll('.palette-question');

        buttons.forEach((button, index) => {
          const questionNum = index + 1;

          // Remove all state classes
          button.classList.remove('current', 'answered', 'not-attempted', 'marked');

          // Add current state
          if (index === this.currentQuestionIndex) {
            button.classList.add('current');
          }

          // Add answer/review state
          if (this.markedForReview.has(questionNum)) {
            button.classList.add('marked');
          } else if (this.answers[questionNum]) {
            button.classList.add('answered');
          } else {
            button.classList.add('not-attempted');
          }
        });

        // Update counts
        this.updateCounts();
      }

      // Update answer counts
      updateCounts() {
        const totalQuestions = this.examData.questions.length;
        const answeredCount = Object.keys(this.answers).length;
        const markedCount = this.markedForReview.size;
        const notAttemptedCount = totalQuestions - answeredCount;

        document.getElementById('answeredCount').textContent = answeredCount;
        document.getElementById('markedCount').textContent = markedCount;
        document.getElementById('notAttemptedCount').textContent = notAttemptedCount;
      }

      // Show specific question
      showQuestion(index) {
        if (index < 0 || index >= this.examData.questions.length) {
          return;
        }

        this.currentQuestionIndex = index;
        const question = this.examData.questions[index];
        const questionNum = index + 1;

        // Update progress
        const progress = ((index + 1) / this.examData.questions.length) * 100;
        document.getElementById('progressBar').style.width = `${progress}%`;
        document.getElementById('progressText').textContent =
          `Question ${questionNum} of ${this.examData.questions.length}`;

        // Update question header
        document.getElementById('questionNumber').textContent = `Question ${questionNum}`;
        document.getElementById('questionMarks').innerHTML =
          `<i class="fas fa-star"></i> <span>${question.marks} mark${question.marks > 1 ? 's' : ''}</span>`;

        // Update question text with LaTeX support
        const questionTextEl = document.getElementById('questionText');
        questionTextEl.innerHTML = question.question_text;

        // Trigger MathJax to render the question
        if (window.MathJax && window.MathJax.typesetPromise) {
          MathJax.typesetPromise([questionTextEl]).catch((err) => console.log('MathJax error:', err));
        }

        // Update question image
        const imageEl = document.getElementById('questionImage');
        if (question.image_url) {
          imageEl.src = question.image_url;
          imageEl.classList.remove('hidden');
        } else {
          imageEl.classList.add('hidden');
        }

        // Render answer options
        this.renderOptions(question, questionNum);

        // Update navigation buttons
        document.getElementById('prevBtn').disabled = index === 0;
        document.getElementById('nextBtn').textContent =
          index === this.examData.questions.length - 1 ? 'Review' : 'Next';

        if (index === this.examData.questions.length - 1) {
          document.getElementById('nextBtn').innerHTML =
            'Review & Submit <i class="fas fa-check-circle"></i>';
          document.getElementById('nextBtn').classList.add('btn-success');
          document.getElementById('nextBtn').classList.remove('btn-primary');
        } else {
          document.getElementById('nextBtn').innerHTML =
            'Next <i class="fas fa-chevron-right"></i>';
          document.getElementById('nextBtn').classList.add('btn-primary');
          document.getElementById('nextBtn').classList.remove('btn-success');
        }

        // Update mark review button
        const markBtn = document.getElementById('markReviewBtn');
        if (this.markedForReview.has(questionNum)) {
          markBtn.innerHTML = '<i class="fas fa-bookmark"></i> Unmark Review';
          markBtn.style.background = '#D97706';
        } else {
          markBtn.innerHTML = '<i class="fas fa-bookmark"></i> Mark for Review';
          markBtn.style.background = '';
        }

        // Update palette
        this.updatePalette();

        // Save progress
        this.saveProgress();

        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }

      // Render answer options
      renderOptions(question, questionNum) {
        const container = document.getElementById('answerOptions');
        container.innerHTML = '';

        const options = ['A', 'B', 'C', 'D'];
        const optionTexts = [
          question.option_a,
          question.option_b,
          question.option_c,
          question.option_d
        ];

        options.forEach((option, idx) => {
          const optionDiv = document.createElement('div');
          optionDiv.className = 'option-item';

          const input = document.createElement('input');
          input.type = 'radio';
          input.name = `question_${questionNum}`;
          input.id = `option_${option}`;
          input.value = option;

          // Check if this option was previously selected
          if (this.answers[questionNum] === option) {
            input.checked = true;
          }

          input.addEventListener('change', () => this.selectOption(option));

          const label = document.createElement('label');
          label.className = 'option-label';
          label.htmlFor = `option_${option}`;
          label.innerHTML = `
            <div class="option-indicator">${option}</div>
            <div class="option-text">${optionTexts[idx] || 'Option not available'}</div>
          `;

          optionDiv.appendChild(input);
          optionDiv.appendChild(label);
          container.appendChild(optionDiv);
        });

        // Trigger MathJax to render the options
        if (window.MathJax && window.MathJax.typesetPromise) {
          MathJax.typesetPromise([container]).catch((err) => console.log('MathJax error:', err));
        }
      }

      // Select an answer option
      async selectOption(option) {
        const questionNum = this.currentQuestionIndex + 1;
        this.answers[questionNum] = option;

        // Check the radio button
        const radio = document.getElementById(`option_${option}`);
        if (radio) {
          radio.checked = true;
        }

        // Save to backend
        try {
          await api.submitMCQAnswer(this.examId, questionNum, option);
          console.log(`Saved answer: Q${questionNum} = ${option}`);
        } catch (error) {
          console.error('Error saving answer:', error);
          Toast.error('Failed to save answer. It will be saved locally.');
        }

        // Update UI
        this.updatePalette();
        this.saveProgress();
      }

      // Toggle mark for review
      toggleMarkReview() {
        const questionNum = this.currentQuestionIndex + 1;

        if (this.markedForReview.has(questionNum)) {
          this.markedForReview.delete(questionNum);
        } else {
          this.markedForReview.add(questionNum);
        }

        this.updatePalette();
        this.saveProgress();

        // Update button text
        const markBtn = document.getElementById('markReviewBtn');
        if (this.markedForReview.has(questionNum)) {
          markBtn.innerHTML = '<i class="fas fa-bookmark"></i> Unmark Review';
          markBtn.style.background = '#D97706';
          Toast.info('Question marked for review');
        } else {
          markBtn.innerHTML = '<i class="fas fa-bookmark"></i> Mark for Review';
          markBtn.style.background = '';
          Toast.info('Review mark removed');
        }
      }

      // Navigate to previous question
      previousQuestion() {
        if (this.currentQuestionIndex > 0) {
          this.showQuestion(this.currentQuestionIndex - 1);
        }
      }

      // Navigate to next question (or show review/submit on last question)
      nextQuestion() {
        if (this.currentQuestionIndex < this.examData.questions.length - 1) {
          this.showQuestion(this.currentQuestionIndex + 1);
        } else {
          // On last question, show submit confirmation with review
          this.confirmSubmit();
        }
      }

      // Start the timer
      startTimer() {
        const timerDisplay = document.getElementById('timerDisplay');
        const timerText = document.getElementById('timerText');

        this.timerInterval = setInterval(() => {
          this.timeRemaining--;

          // Update display
          const minutes = Math.floor(this.timeRemaining / 60);
          const seconds = this.timeRemaining % 60;
          timerText.textContent =
            `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

          // Color coding
          timerDisplay.classList.remove('warning', 'critical');
          if (this.timeRemaining <= 300) { // 5 minutes
            timerDisplay.classList.add('critical');
          } else if (this.timeRemaining <= 600) { // 10 minutes
            timerDisplay.classList.add('warning');
          }

          // Auto-submit when time runs out
          if (this.timeRemaining <= 0) {
            clearInterval(this.timerInterval);
            Toast.warning('Time is up! Auto-submitting exam...');
            setTimeout(() => this.submitExam(), 2000);
          }

          // Save progress every minute
          if (this.timeRemaining % 60 === 0) {
            this.saveProgress();
          }

        }, 1000);
      }

      // Show submit confirmation
      confirmSubmit() {
        const answeredCount = Object.keys(this.answers).length;
        const totalQuestions = this.examData.questions.length;
        const unansweredCount = totalQuestions - answeredCount;
        const markedCount = this.markedForReview.size;

        const summaryHTML = `
          <div class="exam-summary">
            <div class="exam-summary-item">
              <span class="summary-label">Total Questions:</span>
              <span class="summary-value">${totalQuestions}</span>
            </div>
            <div class="exam-summary-item">
              <span class="summary-label">Answered:</span>
              <span class="summary-value answered">${answeredCount}</span>
            </div>
            <div class="exam-summary-item">
              <span class="summary-label">Unanswered:</span>
              <span class="summary-value unanswered">${unansweredCount}</span>
            </div>
            <div class="exam-summary-item">
              <span class="summary-label">Marked for Review:</span>
              <span class="summary-value marked">${markedCount}</span>
            </div>
          </div>
          <p style="margin-top: 1.5rem; color: var(--color-gray-700);">
            ${unansweredCount > 0 ?
              `<strong>Warning:</strong> You have ${unansweredCount} unanswered question${unansweredCount > 1 ? 's' : ''}.` :
              'You have answered all questions.'}
          </p>
          <p style="margin-top: 0.5rem; color: var(--color-gray-700);">
            Are you sure you want to submit the exam? This action cannot be undone.
          </p>
        `;

        Modal.show(summaryHTML, {
          title: 'Submit Exam',
          size: 'md',
          confirmText: 'Submit Exam',
          cancelText: 'Continue Exam',
          onConfirm: () => this.submitExam(),
        });
      }

      // Submit the exam
      async submitExam() {
        // Stop timer
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }

        // Mark exam as submitted to prevent beforeunload warning
        this.isSubmitted = true;

        // Show loading overlay
        document.getElementById('loadingOverlay').classList.add('show');

        try {
          // Submit to backend
          const result = await api.submitExam(this.examId);

          // Clear progress
          const progressKey = `exam_progress_${this.examId}`;
          localStorage.removeItem(progressKey);
          localStorage.removeItem('current_exam');

          // Show success message
          Toast.success('Exam submitted successfully!');

          // Redirect to results page
          setTimeout(() => {
            window.location.href = `./exam-results.html?id=${this.examId}`;
          }, 1500);

        } catch (error) {
          console.error('Error submitting exam:', error);
          Toast.error('Failed to submit exam. Please try again.');
          document.getElementById('loadingOverlay').classList.remove('show');

          // Reset submitted flag and restart timer
          this.isSubmitted = false;
          this.startTimer();
        }
      }
    }

    // Initialize exam when page loads
    let examManager;

    document.addEventListener('DOMContentLoaded', () => {
      examManager = new ExamManager();
    });

    // Warn before leaving page (but not after successful submission)
    window.addEventListener('beforeunload', (e) => {
      if (examManager && examManager.timerInterval && !examManager.isSubmitted) {
        e.preventDefault();
        e.returnValue = 'Your exam is in progress. Are you sure you want to leave?';
        return e.returnValue;
      }
    });

  </script>

</body>
</html>
